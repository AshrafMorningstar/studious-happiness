"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnimatedImage = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const cancel_render_js_1 = require("../cancel-render.js");
const delay_render_js_1 = require("../delay-render.js");
const use_current_frame_js_1 = require("../use-current-frame.js");
const use_video_config_js_1 = require("../use-video-config.js");
const canvas_1 = require("./canvas");
const decode_image_js_1 = require("./decode-image.js");
const resolve_image_source_1 = require("./resolve-image-source");
exports.AnimatedImage = (0, react_1.forwardRef)(({ src, width, height, onError, loopBehavior = 'loop', playbackRate = 1, onLoad, fit = 'fill', ...props }, canvasRef) => {
    const resolvedSrc = (0, resolve_image_source_1.resolveAnimatedImageSource)(src);
    const [imageDecoder, setImageDecoder] = (0, react_1.useState)(null);
    const [id] = (0, react_1.useState)(() => (0, delay_render_js_1.delayRender)(`Rendering <AnimatedImage/> with src="${resolvedSrc}"`));
    const frame = (0, use_current_frame_js_1.useCurrentFrame)();
    const { fps } = (0, use_video_config_js_1.useVideoConfig)();
    const currentTime = frame / fps;
    const currentTimeRef = (0, react_1.useRef)(currentTime);
    currentTimeRef.current = currentTime;
    const ref = (0, react_1.useRef)(null);
    (0, react_1.useImperativeHandle)(canvasRef, () => {
        var _a;
        const c = (_a = ref.current) === null || _a === void 0 ? void 0 : _a.getCanvas();
        if (!c) {
            throw new Error('Canvas ref is not set');
        }
        return c;
    }, []);
    (0, react_1.useEffect)(() => {
        const controller = new AbortController();
        (0, decode_image_js_1.decodeImage)({
            resolvedSrc,
            signal: controller.signal,
            currentTime: currentTimeRef.current,
        })
            .then((d) => {
            setImageDecoder(d);
        })
            .catch((err) => {
            if (err.name === 'AbortError') {
                return;
            }
            // TODO: Allow to catch error
            (0, cancel_render_js_1.cancelRender)(err);
        });
        return () => {
            controller.abort();
        };
    }, [resolvedSrc, id, onLoad, onError]);
    (0, react_1.useEffect)(() => {
        if (!imageDecoder) {
            return;
        }
        imageDecoder.getFrame(currentTime).then((videoFrame) => {
            var _a;
            (_a = ref.current) === null || _a === void 0 ? void 0 : _a.draw(videoFrame.frame);
        });
    }, [currentTime, imageDecoder]);
    return ((0, jsx_runtime_1.jsx)(canvas_1.Canvas, { ref: ref, width: width, height: height, fit: fit, ...props }));
});
